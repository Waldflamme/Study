#Создать двухмерный массив 30 на 4, содержащий случайные целые числа от 0 до 100.
#Интерпретируя массив как 30 векторов из 4х компонент, вернуть массив 5 на 4, состоящий из векторов с наибольшей длиной (евклидовой нормой).
#Решить задачу средствами numpy и/или pandas. Не использовать циклы и конструкции стандартного Python там, где можно использовать возможности данных библиотек.


import numpy as np  # Импорт библиотеки NumPy

# Шаг 1: создаём массив 30×4 со случайными целыми числами от 0 до 100 включительно
data = np.random.randint(0, 101, size=(30, 4))
# np.random.randint(0, 101, size=(30, 4)) создаёт массив из 30 строк и 4 столбцов со случайными целыми значениями от 0 до 100

# Шаг 2: считаем евклидову норму (длину) для каждой строки (вектора)
norms = np.linalg.norm(data, axis=1)
# np.linalg.norm(..., axis=1): вычисляет евклидову норму (корень из суммы квадратов) по каждой строке

# Шаг 3: находим индексы 5 строк с наибольшей нормой
top5_indices = np.argsort(norms)[-5:][::-1]
# np.argsort(norms): возвращает индексы, которые отсортировали бы массив норм по возрастанию
# [-5:]: берём последние 5 индексов (наибольшие нормы)
# [::-1]: инвертируем порядок — получаем от самого большого к меньшему

# Шаг 4: получаем соответствующие векторы
top5_vectors = data[top5_indices]
# Обращаемся по индексам — получаем итоговый массив 5×4

# Шаг 5: вывод
print("Исходный массив (30×4):\n", data)
print("\nЕвклидовы нормы векторов:\n", norms)
print("\nИндексы 5 векторов с наибольшей длиной:\n", top5_indices)
print("\nРезультат (5×4 — векторы с наибольшей нормой):\n", top5_vectors)